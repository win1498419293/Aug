package lib

import (
	"encoding/json"
	"fmt"
	"github.com/fatih/color"
	"io/ioutil"
	"log"
	"net"
	"net/url"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"time"
)

type AutoGenerated struct {
	WorkingEvent struct {
		URL           string `json:"url"`
		Title         string `json:"title"`
		Webserver     string `json:"webserver"`
		ContentType   string `json:"content-type"`
		ContentLength int    `json:"content-length"`
		StatusCode    int    `json:"status-code"`
	} `json:"WorkingEvent"`
	Info struct {
		Banner  string `json:"Banner"`
		Service string `json:"Service"`
		Cert    string `json:"Cert"`
	} `json:"info"`
	Time   time.Time `json:"time"`
	Target string    `json:"Target"`
}

type TxPortMapStruct struct {
	Target     string
	Surl       string
	Src        string
	Url        string
	Banner     string
	Service    string
	Title      string
	Webserver  string
	StatusCode string
	Times      string
}

// 如有多个ip情况仅获取第一个ip
func Getoneip(urls string) string {
	u, err := url.Parse(urls)
	addr, err := net.ResolveIPAddr("ip", u.Host)
	if err != nil {
		fmt.Println("Resolution error", err.Error())
		os.Exit(1)
	}
	fmt.Println("Resolved address is ", addr.String())
	os.Exit(0)
	return addr.String()
}

// 获取查到的所有ip
func Getallip(urls string) []string {
	ipc := []string{}
	u, err := url.Parse(urls)
	ips, err := net.LookupHost(u.Host)
	if err != nil {
		fmt.Println("Error: ", err)
	}
	for _, ip := range ips {
		// 输出 IP 地址
		fmt.Println("IP addresses: ", ip)
		ipc = append(ipc, ip)
	}
	return ipc

}

// 不带输出返回结果
func Cdncheck(ip string) (bool, string) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("cdncheck出现错误:", err)
		}
	}()
	flag := false
	now := time.Now()
	currentdata := now.Format("2006-01-02")
	CDNcheckresultFilePath := Readyaml("CDNcheck.resultFilePath")
	CDNcheckexe := Readyaml("CDNcheck.CDNcheckexe")
	resultfile, err := os.Stat(CDNcheckresultFilePath)
	if !(err == nil && resultfile.Size() > 0) {
		os.Mkdir(CDNcheckresultFilePath, os.ModePerm)
	}
	PortScan, err := os.OpenFile("log/PortScan.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
	com := "./cdncheck.exe -u " + ip + " -o result\\" + currentdata + ip + ".txt"
	cmd := exec.Command("cmd", "/c", "start "+com)
	cmd.Dir = CDNcheckexe
	err = cmd.Start()
	if err != nil {
		log.Fatalf("cmd.Run() failed with %s\n", err)
	}
	flags := cmd.Wait()
	if flags == nil {
		fmt.Println(ip + ":    cdn检测结束")
	}

	// 使用 Stat 函数获取文件信息
	resultfiles, err := os.Stat(CDNcheckresultFilePath + currentdata + ip + ".txt")

	// 判断文件是否存在
	if err == nil && resultfiles.Size() > 0 {
		txts := Readfile(CDNcheckresultFilePath + currentdata + ip + ".txt")
		for i := 0; i < len(txts); i++ {
			if !strings.Contains(txts[i], "未使用CDN或CDN") {
				fmt.Println(ip, ":存在CDN")
				flag = true
			}
		}

	} else if os.IsNotExist(err) {
		flag = false
		//fmt.Println("文件不存在")
	}
	//写入日志
	log.SetOutput(PortScan)
	return flag, ip + currentdata
}

// waf检测，返回是否存在waf以及waf名称
func Wafcheck(url string) (bool, string) {
	wafw00ffresultFilePath := Readyaml("wafw00f.resultFilePath")
	wafw00ffile := Readyaml("wafw00f.wafw00ffile")
	resultfile, err := os.Stat(wafw00ffresultFilePath)
	if !(err == nil && resultfile.Size() > 0) {
		os.Mkdir(wafw00ffresultFilePath, os.ModePerm)
	}
	flag := false
	PortScan, err := os.OpenFile("log/PortScan.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
	com := "python main.py " + url + " -o result\\" + "result.txt"
	cmd := exec.Command("cmd", "/c", com)
	cmd.Dir = wafw00ffile
	//fmt.Println(com)
	err = cmd.Run()

	flags := cmd.Wait()
	if flags == nil {
		fmt.Println(url + ":   waf检测结束")
	}
	// 使用 Stat 函数获取文件信息
	data, err := ioutil.ReadFile(wafw00ffresultFilePath + "result.txt")
	if err != nil {
		log.Println(err)
	}
	waf := []string{"", "", ""}
	if len(data) > 0 {
		waf = strings.Split(string(data), "   ")
		//fmt.Println(waf)
		if !strings.Contains(waf[2], "None") {
			//log.Println(url, ":存在WAF：", waf[2])
			flag = true
		} else {
			//log.Println(url, ":不存在WAF：", waf[2])
			flag = false
		}
	}
	//写入日志
	log.SetOutput(PortScan)
	return flag, waf[2]

}

func GetPortResult(TPMRP string) map[int]map[string]string {
	TxPortMap := make(map[int]map[string]string)
	resultfile, err := os.Stat(TPMRP)
	i := 0
	if err == nil && resultfile.Size() > 0 {
		file, err := os.Open(TPMRP)
		if err != nil {
			fmt.Println(err)
		}
		defer file.Close()

		decoder := json.NewDecoder(file)
		for {
			var event AutoGenerated
			err := decoder.Decode(&event)
			if err != nil {
				break
			}
			times := event.Time.Format("2006-01-02 15:04:05")
			TxPortMap[i] = make(map[string]string)
			TxPortMap[i]["Target"] = event.Target
			TxPortMap[i]["Url"] = event.WorkingEvent.URL
			TxPortMap[i]["Banner"] = event.Info.Banner
			TxPortMap[i]["Service"] = event.Info.Service
			TxPortMap[i]["Title"] = event.WorkingEvent.Title
			TxPortMap[i]["Webserver"] = event.WorkingEvent.Webserver
			TxPortMap[i]["StatusCode"] = strconv.Itoa(event.WorkingEvent.StatusCode)
			TxPortMap[i]["Times"] = times
			i++
		}

	}
	return TxPortMap
}

// 调用TxPortMap 扫描输入的ip获取开放的端口及web服务信息
func IpScan(flag bool, params ...string) {
	c := color.New()
	c.Add(color.FgRed, color.Bold)
	now := time.Now()
	ip = params[0]
	ports = params[1]
	src = params[2]
	surl := " "
	if len(params) >= 3 {
		surl = params[3]
	}

	if ports != "-t1000" {
		ports = " -p " + ports
	}

	TxPortMapresultFilePath := Readyaml("TxPortMap.resultFilePath")
	TxPortMapexe := Readyaml("TxPortMap.TxPortMapexe")
	currentdata := now.Format("2006-01-02")
	resultfile, err := os.Stat(TxPortMapresultFilePath)
	if !(err == nil && resultfile.Size() <= 0) {
		os.Mkdir(TxPortMapresultFilePath, os.ModePerm)
	}
	PortScan, err := os.OpenFile("log/PortScan.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
	com := "TxPortMap  -i " + ip + "  " + ports + "  -json -o result\\" + ip + currentdata + ".json"
	cmd := exec.Command("cmd", "/c", com)
	cmd.Dir = TxPortMapexe
	err = cmd.Run()

	if err != nil {
		log.Fatalf("cmd.Run() failed with %s\n", err)
	}

	flags := cmd.Wait()
	if flags == nil {
		fmt.Println("端口扫描结束")
	}

	TxPortMap := GetPortResult(TxPortMapresultFilePath + ip + currentdata + ".json")
	for _, value := range TxPortMap {
		tpms := TxPortMapStruct{
			Src:        src,
			Surl:       surl,
			Target:     value["Target"],
			Url:        value["Url"],
			Service:    value["Service"],
			Banner:     value["Banner"],
			Title:      value["Title"],
			StatusCode: value["StatusCode"],
			Webserver:  value["Webserver"],
			Times:      value["Times"],
		}
		c.Println("Target:", value["Target"], "Service: ", value["Service"], "Banner: ", value["Banner"])
		if flag {
			tpms.InsertTaskTables()
		}
	}

	log.SetOutput(PortScan)
}
